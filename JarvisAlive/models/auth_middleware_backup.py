"""Authentication middleware for session management and user mapping."""

import asyncio
import json
import logging
from datetime import datetime, timezone, timedelta
from typing import Dict, Any, Optional, List
import redis.asyncio as redis
from .user_profile import UserProfile, UserSession, UserUsage, UserQuota, UserTier

logger = logging.getLogger(__name__)


class AuthMiddleware:
    """Middleware for handling authentication, session management, and user mapping."""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.session_prefix = "session:"
        self.user_prefix = "user:"
        self.usage_prefix = "usage:"
        self.quota_prefix = "quota:"
    
    async def migrate_anonymous_session(self, user_id: str, anonymous_session_id: str) -> str:
        """Migrate an anonymous session to a user account."""
        try:
            # Get anonymous session data
            anonymous_key = f"{self.session_prefix}{anonymous_session_id}"
            session_data = await self.redis.get(anonymous_key)
            
            if not session_data:
                logger.info(f"No anonymous session found for {anonymous_session_id}")
                return f"{user_id}:{anonymous_session_id}"
            
            # Parse session data
            session_dict = json.loads(session_data)
            
            # Create new user session
            user_session_id = f"{user_id}:{anonymous_session_id}"
            user_session = UserSession(
                id=user_session_id,
                user_id=user_id,
                original_session_id=anonymous_session_id,
                context=session_dict,
                created_at=datetime.now(timezone.utc)
            )
            
            # Store user session
            await self.store_user_session(user_session)
            
            # Copy all session-related data
            await self._copy_session_data(anonymous_session_id, user_session_id)
            
            # Remove anonymous session
            await self.redis.delete(anonymous_key)
            
            logger.info(f"Migrated anonymous session {anonymous_session_id} to user {user_id}")
            return user_session_id
            
        except Exception as e:
            logger.error(f"Error migrating anonymous session: {e}")
            return f"{user_id}:{anonymous_session_id}"
    
    async def _copy_session_data(self, old_session_id: str, new_session_id: str):\n        \"\"\"Copy all session-related data from old to new session.\"\"\"\n        try:\n            # Get all keys related to the old session\n            pattern = f\"*{old_session_id}*\"\n            keys = await self.redis.keys(pattern)\n            \n            for key in keys:\n                key_str = key.decode('utf-8') if isinstance(key, bytes) else key\n                \n                # Skip the main session key (already handled)\n                if key_str == f\"{self.session_prefix}{old_session_id}\":\n                    continue\n                \n                # Create new key with new session ID\n                new_key = key_str.replace(old_session_id, new_session_id)\n                \n                # Copy the data\n                data = await self.redis.get(key)\n                if data:\n                    await self.redis.set(new_key, data)\n                \n                # Copy TTL if exists\n                ttl = await self.redis.ttl(key)\n                if ttl > 0:\n                    await self.redis.expire(new_key, ttl)\n                \n                # Delete old key\n                await self.redis.delete(key)\n                \n        except Exception as e:\n            logger.error(f\"Error copying session data: {e}\")\n    \n    async def get_or_create_user_profile(self, user_id: str, email: str) -> UserProfile:\n        \"\"\"Get existing user profile or create new one.\"\"\"\n        try:\n            # Try to get existing profile\n            profile_key = f\"{self.user_prefix}{user_id}\"\n            profile_data = await self.redis.get(profile_key)\n            \n            if profile_data:\n                profile_dict = json.loads(profile_data)\n                return UserProfile(**profile_dict)\n            \n            # Create new profile\n            profile = UserProfile(\n                id=user_id,\n                email=email,\n                tier=UserTier.FREE,\n                created_at=datetime.now(timezone.utc)\n            )\n            \n            # Update limits based on tier\n            profile.update_limits()\n            \n            # Store profile\n            await self.store_user_profile(profile)\n            \n            # Initialize usage tracking\n            await self.initialize_user_usage(user_id)\n            \n            logger.info(f\"Created new user profile for {user_id}\")\n            return profile\n            \n        except Exception as e:\n            logger.error(f\"Error getting/creating user profile: {e}\")\n            # Return default profile on error\n            return UserProfile(id=user_id, email=email)\n    \n    async def store_user_profile(self, profile: UserProfile):\n        \"\"\"Store user profile in Redis.\"\"\"\n        try:\n            profile_key = f\"{self.user_prefix}{profile.id}\"\n            profile_data = profile.model_dump_json()\n            \n            # Store with 7-day expiration\n            await self.redis.setex(profile_key, 7 * 24 * 3600, profile_data)\n            \n        except Exception as e:\n            logger.error(f\"Error storing user profile: {e}\")\n    \n    async def store_user_session(self, session: UserSession):\n        \"\"\"Store user session in Redis.\"\"\"\n        try:\n            session_key = f\"{self.session_prefix}{session.id}\"\n            session_data = session.model_dump_json()\n            \n            # Store with 24-hour expiration\n            await self.redis.setex(session_key, 24 * 3600, session_data)\n            \n        except Exception as e:\n            logger.error(f\"Error storing user session: {e}\")\n    \n    async def get_user_session(self, session_id: str) -> Optional[UserSession]:\n        \"\"\"Get user session from Redis.\"\"\"\n        try:\n            session_key = f\"{self.session_prefix}{session_id}\"\n            session_data = await self.redis.get(session_key)\n            \n            if session_data:\n                session_dict = json.loads(session_data)\n                return UserSession(**session_dict)\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error getting user session: {e}\")\n            return None\n    \n    async def update_user_activity(self, session_id: str):\n        \"\"\"Update user activity timestamp.\"\"\"\n        try:\n            session = await self.get_user_session(session_id)\n            if session:\n                session.update_activity()\n                await self.store_user_session(session)\n                \n        except Exception as e:\n            logger.error(f\"Error updating user activity: {e}\")\n    \n    async def initialize_user_usage(self, user_id: str):\n        \"\"\"Initialize usage tracking for a user.\"\"\"\n        try:\n            current_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n            \n            # Check if usage already exists\n            usage_key = f\"{self.usage_prefix}{user_id}:{current_month}\"\n            existing_usage = await self.redis.get(usage_key)\n            \n            if not existing_usage:\n                # Create new usage record\n                usage = UserUsage(\n                    user_id=user_id,\n                    month=current_month\n                )\n                \n                usage_data = usage.model_dump_json()\n                await self.redis.setex(usage_key, 32 * 24 * 3600, usage_data)  # 32 days\n                \n                # Initialize quotas\n                await self.initialize_user_quotas(user_id)\n                \n        except Exception as e:\n            logger.error(f\"Error initializing user usage: {e}\")\n    \n    async def initialize_user_quotas(self, user_id: str):\n        \"\"\"Initialize user quotas based on their tier.\"\"\"\n        try:\n            # Get user profile to determine tier\n            profile = await self.get_or_create_user_profile(user_id, \"\")\n            limits = profile.get_tier_limits()\n            \n            # Current month\n            current_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n            next_month = (datetime.now(timezone.utc) + timedelta(days=32)).replace(day=1)\n            \n            # Create quotas\n            quotas = [\n                UserQuota(\n                    user_id=user_id,\n                    quota_type=\"requests\",\n                    limit=limits[\"monthly_requests\"],\n                    reset_date=next_month\n                ),\n                UserQuota(\n                    user_id=user_id,\n                    quota_type=\"agents\",\n                    limit=limits[\"agent_limit\"],\n                    reset_date=next_month\n                ),\n                UserQuota(\n                    user_id=user_id,\n                    quota_type=\"storage\",\n                    limit=limits[\"storage_limit_mb\"],\n                    reset_date=next_month\n                )\n            ]\n            \n            # Store quotas\n            for quota in quotas:\n                quota_key = f\"{self.quota_prefix}{user_id}:{quota.quota_type}:{current_month}\"\n                quota_data = quota.model_dump_json()\n                await self.redis.setex(quota_key, 32 * 24 * 3600, quota_data)\n                \n        except Exception as e:\n            logger.error(f\"Error initializing user quotas: {e}\")\n    \n    async def track_api_request(self, user_id: str, endpoint: str, processing_time: float):\n        \"\"\"Track API request for usage monitoring.\"\"\"\n        try:\n            current_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n            \n            # Update usage\n            usage_key = f\"{self.usage_prefix}{user_id}:{current_month}\"\n            usage_data = await self.redis.get(usage_key)\n            \n            if usage_data:\n                usage_dict = json.loads(usage_data)\n                usage = UserUsage(**usage_dict)\n                usage.add_request(endpoint, processing_time)\n                \n                # Store updated usage\n                await self.redis.setex(usage_key, 32 * 24 * 3600, usage.model_dump_json())\n                \n                # Update quota\n                await self.consume_quota(user_id, \"requests\", 1)\n                \n        except Exception as e:\n            logger.error(f\"Error tracking API request: {e}\")\n    \n    async def track_agent_creation(self, user_id: str, agent_id: str, agent_type: str):\n        \"\"\"Track agent creation for usage monitoring.\"\"\"\n        try:\n            current_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n            \n            # Update usage\n            usage_key = f\"{self.usage_prefix}{user_id}:{current_month}\"\n            usage_data = await self.redis.get(usage_key)\n            \n            if usage_data:\n                usage_dict = json.loads(usage_data)\n                usage = UserUsage(**usage_dict)\n                usage.add_agent(agent_id, agent_type)\n                \n                # Store updated usage\n                await self.redis.setex(usage_key, 32 * 24 * 3600, usage.model_dump_json())\n                \n                # Update quota\n                await self.consume_quota(user_id, \"agents\", 1)\n                \n        except Exception as e:\n            logger.error(f\"Error tracking agent creation: {e}\")\n    \n    async def track_websocket_connection(self, user_id: str):\n        \"\"\"Track WebSocket connection for usage monitoring.\"\"\"\n        try:\n            current_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n            \n            # Update usage\n            usage_key = f\"{self.usage_prefix}{user_id}:{current_month}\"\n            usage_data = await self.redis.get(usage_key)\n            \n            if usage_data:\n                usage_dict = json.loads(usage_data)\n                usage = UserUsage(**usage_dict)\n                usage.add_websocket_connection()\n                \n                # Store updated usage\n                await self.redis.setex(usage_key, 32 * 24 * 3600, usage.model_dump_json())\n                \n        except Exception as e:\n            logger.error(f\"Error tracking WebSocket connection: {e}\")\n    \n    async def check_quota(self, user_id: str, quota_type: str) -> bool:\n        \"\"\"Check if user has remaining quota.\"\"\"\n        try:\n            current_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n            quota_key = f\"{self.quota_prefix}{user_id}:{quota_type}:{current_month}\"\n            \n            quota_data = await self.redis.get(quota_key)\n            if quota_data:\n                quota_dict = json.loads(quota_data)\n                quota = UserQuota(**quota_dict)\n                return not quota.is_exceeded()\n            \n            # If no quota found, initialize and allow\n            await self.initialize_user_quotas(user_id)\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error checking quota: {e}\")\n            return True  # Allow on error\n    \n    async def consume_quota(self, user_id: str, quota_type: str, amount: int = 1) -> bool:\n        \"\"\"Consume quota amount.\"\"\"\n        try:\n            current_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n            quota_key = f\"{self.quota_prefix}{user_id}:{quota_type}:{current_month}\"\n            \n            quota_data = await self.redis.get(quota_key)\n            if quota_data:\n                quota_dict = json.loads(quota_data)\n                quota = UserQuota(**quota_dict)\n                \n                if quota.consume(amount):\n                    # Store updated quota\n                    await self.redis.setex(quota_key, 32 * 24 * 3600, quota.model_dump_json())\n                    return True\n                return False\n            \n            return True  # Allow if no quota found\n            \n        except Exception as e:\n            logger.error(f\"Error consuming quota: {e}\")\n            return True  # Allow on error\n    \n    async def get_user_usage(self, user_id: str) -> Optional[UserUsage]:\n        \"\"\"Get current month's usage for a user.\"\"\"\n        try:\n            current_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n            usage_key = f\"{self.usage_prefix}{user_id}:{current_month}\"\n            \n            usage_data = await self.redis.get(usage_key)\n            if usage_data:\n                usage_dict = json.loads(usage_data)\n                return UserUsage(**usage_dict)\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error getting user usage: {e}\")\n            return None\n    \n    async def get_user_quotas(self, user_id: str) -> List[UserQuota]:\n        \"\"\"Get all quotas for a user.\"\"\"\n        try:\n            current_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n            quota_types = [\"requests\", \"agents\", \"storage\"]\n            quotas = []\n            \n            for quota_type in quota_types:\n                quota_key = f\"{self.quota_prefix}{user_id}:{quota_type}:{current_month}\"\n                quota_data = await self.redis.get(quota_key)\n                \n                if quota_data:\n                    quota_dict = json.loads(quota_data)\n                    quotas.append(UserQuota(**quota_dict))\n            \n            return quotas\n            \n        except Exception as e:\n            logger.error(f\"Error getting user quotas: {e}\")\n            return []\n    \n    async def cleanup_expired_sessions(self):\n        \"\"\"Clean up expired sessions and related data.\"\"\"\n        try:\n            # Get all session keys\n            session_pattern = f\"{self.session_prefix}*\"\n            session_keys = await self.redis.keys(session_pattern)\n            \n            for key in session_keys:\n                key_str = key.decode('utf-8') if isinstance(key, bytes) else key\n                session_data = await self.redis.get(key)\n                \n                if session_data:\n                    session_dict = json.loads(session_data)\n                    session = UserSession(**session_dict)\n                    \n                    if session.is_expired():\n                        # Delete expired session\n                        await self.redis.delete(key)\n                        logger.info(f\"Cleaned up expired session: {session.id}\")\n                        \n        except Exception as e:\n            logger.error(f\"Error cleaning up expired sessions: {e}\")